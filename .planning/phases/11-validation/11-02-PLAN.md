---
phase: 11-validation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
    - cmd/kamaji/validate.go
    - cmd/kamaji/main.go
autonomous: true

must_haves:
    truths:
        - "User can run `kamaji validate` command"
        - "Valid config prints success message and exits 0"
        - "Invalid config prints all errors and exits 1"
        - "YAML syntax errors include error message from parser"
        - "Validation errors include field paths"
    artifacts:
        - path: "cmd/kamaji/validate.go"
          provides: "Validate command implementation"
          exports: ["validateCmd"]
        - path: "cmd/kamaji/main.go"
          provides: "Root command with validate subcommand"
          contains: "AddCommand(validateCmd())"
    key_links:
        - from: "cmd/kamaji/validate.go"
          to: "internal/config/validate.go"
          via: "ValidateSprint call"
          pattern: "config\\.ValidateSprint"
        - from: "cmd/kamaji/validate.go"
          to: "internal/output/styles.go"
          via: "Error output styling"
          pattern: "output\\.(PrintError|PrintSuccess)"
        - from: "cmd/kamaji/main.go"
          to: "cmd/kamaji/validate.go"
          via: "AddCommand registration"
          pattern: "AddCommand\\(validateCmd\\(\\)\\)"
---

<objective>
Create the `kamaji validate` command that validates kamaji.yaml and reports all errors.

Purpose: Satisfies VALD-01 (user can run validate) and VALD-04 (clear error messages).
Output: Working validate command integrated into kamaji CLI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-validation/11-RESEARCH.md
@.planning/phases/11-validation/11-01-SUMMARY.md

@cmd/kamaji/start.go
@cmd/kamaji/main.go
@internal/config/sprint.go
@internal/output/styles.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validate command</name>
  <files>cmd/kamaji/validate.go</files>
  <action>
    Create validate.go following start.go patterns:

    1. Define sentinel error: `var errConfigInvalid = errors.New("config invalid")`

    2. Create validateCmd() returning *cobra.Command:
       - Use: "validate"
       - Short: "Validate kamaji.yaml configuration"
       - RunE handler that:
         a. Gets working directory
         b. Calls config.LoadSprint() - if error, it's YAML syntax or file not found
         c. If LoadSprint succeeds, calls config.ValidateSprint() for semantic checks
         d. Prints all errors with field paths using output package
         e. Returns errConfigInvalid if any errors, nil if valid
       - Set SilenceUsage = true (same as start.go)

    3. Error output format (using output.PrintError):
       - YAML/file errors: "Error: {error message}"
       - Validation errors: header + bullet list with field paths
       - Example:
         ```
         Error: Configuration validation failed
           tickets[0].description: cannot be empty
           tickets[1].tasks[0].description: cannot be empty
         ```

    4. Success output: output.PrintSuccess("Configuration is valid")

    Follow existing patterns:
    - Use os.Getwd() like start.go
    - Use filepath.Join(workDir, "kamaji.yaml") for config path
    - Use output package for all terminal output

  </action>
  <verify>go build ./cmd/kamaji/... compiles without errors</verify>
  <done>validate.go exists with validateCmd function</done>
</task>

<task type="auto">
  <name>Task 2: Wire validate into root command</name>
  <files>cmd/kamaji/main.go</files>
  <action>
    1. In rootCmd(), add: cmd.AddCommand(validateCmd())

    2. In main(), add errConfigInvalid to the error check:
       - Change: `if !errors.Is(err, errSprintFailed)`
       - To: `if !errors.Is(err, errSprintFailed) && !errors.Is(err, errConfigInvalid)`

    This prevents double-printing of the error message (validate already printed details).

  </action>
  <verify>`kamaji validate --help` shows help text</verify>
  <done>validate command appears in `kamaji --help` output</done>
</task>

<task type="auto">
  <name>Task 3: Manual verification of validate command</name>
  <files>-</files>
  <action>
    Create temporary test files and verify behavior:

    1. Valid config test:
       - Create temp kamaji.yaml with valid content
       - Run kamaji validate
       - Expect: success message, exit 0

    2. Missing file test:
       - Run kamaji validate in empty directory
       - Expect: error about missing file, exit 1

    3. Invalid YAML test:
       - Create kamaji.yaml with syntax error
       - Run kamaji validate
       - Expect: YAML parse error message, exit 1

    4. Semantic error test:
       - Create kamaji.yaml with empty ticket description
       - Run kamaji validate
       - Expect: error with field path, exit 1

    Clean up temp files after testing.

  </action>
  <verify>All four test scenarios produce expected output</verify>
  <done>Validate command works end-to-end for valid and invalid configs</done>
</task>

</tasks>

<verification>
1. `make build` succeeds
2. `kamaji validate --help` shows command help
3. `kamaji --help` lists validate as subcommand
4. `make test` passes
5. `make lint` passes
</verification>

<success_criteria>

- `kamaji validate` command exists and runs
- Valid config: prints success, exits 0
- Invalid YAML: prints parse error, exits 1
- Missing required fields: prints field paths, exits 1
- Empty descriptions: prints field paths, exits 1
- All CI checks pass
  </success_criteria>

<output>
After completion, create `.planning/phases/11-validation/11-02-SUMMARY.md`
</output>
