---
phase: 08-streaming-output
plan: 01
wave: 1
type: execute
depends_on: []
files_modified:
    [
        internal/output/styles.go,
        internal/output/styles_test.go,
        internal/output/writer.go,
        internal/output/writer_test.go,
        internal/config/plain.go,
        internal/config/plain_test.go,
    ]
autonomous: true
---

<objective>
Create output styling infrastructure with lipgloss and plain mode support.

Purpose: Enable formatted terminal output that respects user preferences for styled or ASCII-only display.
Output: Output package with styles, styled writer, and config.IsPlain() flag.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DESIGN.md

**Existing infrastructure:**
@internal/process/process.go - WithStdout/WithStderr options
@internal/mcp/tools.go - Signal struct definition

**From DESIGN.md - Plain mode indicators:**

- `[ok]` — Success
- `Error:` — Error
- `->` — Info
- `Warning:` — Warning
- `[DEBUG]` — Debug

**Dependencies:**

- github.com/charmbracelet/lipgloss v1.0.0 (already in go.mod)
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add config.IsPlain() flag</name>
  <files>internal/config/plain.go, internal/config/plain_test.go</files>
  <action>
Create plain mode detection in config package:

```go
// internal/config/plain.go
package config

import (
    "os"
    "sync"
)

var (
    plainMode bool
    plainOnce sync.Once
)

// IsPlain returns true when terminal styling should be disabled.
// Checks KAMAJI_PLAIN env var or NO_COLOR standard.
func IsPlain() bool {
    plainOnce.Do(func() {
        if os.Getenv("KAMAJI_PLAIN") != "" {
            plainMode = true
            return
        }
        if os.Getenv("NO_COLOR") != "" {
            plainMode = true
            return
        }
    })
    return plainMode
}

// SetPlain forces plain mode (for testing).
func SetPlain(v bool) {
    plainMode = v
}
```

Tests should cover:

- KAMAJI_PLAIN=1 returns true
- NO_COLOR=1 returns true
- Neither set returns false
- SetPlain overrides detection
  </action>
  <verify>go test -v ./internal/config/... -run Plain passes</verify>
  <done>config.IsPlain() and config.SetPlain() exist with passing tests</done>
  </task>

<task type="auto">
  <name>Task 2: Create lipgloss styles</name>
  <files>internal/output/styles.go, internal/output/styles_test.go</files>
  <action>
Create output package with styled message types:

```go
// internal/output/styles.go
package output

import "github.com/charmbracelet/lipgloss"

type MessageType int

const (
    Success MessageType = iota
    Error
    Info
    Warning
    Debug
)

// Style returns the styled string for the given type and message.
// Respects config.IsPlain() for ASCII fallback.
func Style(t MessageType, msg string) string

// Prefix returns the prefix for a message type.
// Styled: colored emoji/symbol, Plain: ASCII indicator
func Prefix(t MessageType) string
```

Styled prefixes (when IsPlain() is false):

- Success: green checkmark or "[ok]" text
- Error: red "Error:"
- Info: blue arrow "->"
- Warning: yellow "Warning:"
- Debug: dim "[DEBUG]"

Plain prefixes (when IsPlain() is true):

- Success: "[ok]"
- Error: "Error:"
- Info: "->"
- Warning: "Warning:"
- Debug: "[DEBUG]"

Tests should verify both styled and plain output for each type.
</action>
<verify>go test -v ./internal/output/... -run Style passes</verify>
<done>Style() and Prefix() functions work for all message types in both modes</done>
</task>

<task type="auto">
  <name>Task 3: Create styled writer wrapper</name>
  <files>internal/output/writer.go, internal/output/writer_test.go</files>
  <action>
Create a Writer that wraps io.Writer and applies styling:

```go
// internal/output/writer.go
package output

import "io"

// Writer wraps an io.Writer with styled output.
type Writer struct {
    w        io.Writer
    msgType  MessageType
}

// NewWriter creates a styled writer.
func NewWriter(w io.Writer, t MessageType) *Writer

// Write implements io.Writer, prefixing each line with styled prefix.
func (w *Writer) Write(p []byte) (n int, err error)

// Styled writer helpers for common cases:
func NewInfoWriter(w io.Writer) *Writer
func NewErrorWriter(w io.Writer) *Writer
```

The writer should:

- Buffer partial lines until newline
- Apply prefix to start of each complete line
- Pass through raw bytes (no mangling)
- Respect IsPlain() setting

Tests should cover:

- Single line write
- Multi-line write
- Partial line buffering
- Different message types
  </action>
  <verify>go test -v ./internal/output/... -run Writer passes</verify>
  <done>Writer implements io.Writer with styled line prefixes</done>
  </task>

<task type="auto">
  <name>Task 4: Add convenience print functions</name>
  <files>internal/output/styles.go, internal/output/styles_test.go</files>
  <action>
Add convenience functions for common output patterns:

```go
// Print functions write to os.Stdout with appropriate styling
func PrintSuccess(msg string)
func PrintError(msg string)
func PrintInfo(msg string)
func PrintWarning(msg string)
func PrintDebug(msg string)

// Sprintf functions return styled strings without printing
func SuccessMsg(msg string) string
func ErrorMsg(msg string) string
func InfoMsg(msg string) string
func WarningMsg(msg string) string
func DebugMsg(msg string) string
```

These wrap Style() for ergonomic use throughout the codebase.
</action>
<verify>go test -v ./internal/output/... passes all tests</verify>
<done>Convenience functions exist for all message types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./internal/config/...` passes
- [ ] `go test ./internal/output/...` passes
- [ ] `make test` passes all tests
- [ ] `make lint` passes with 0 issues
- [ ] Styles respect IsPlain() setting
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- config.IsPlain() detects plain mode
- Lipgloss styles defined for Success, Error, Info, Warning, Debug
- Styled Writer implements io.Writer for process output
- Both styled and plain modes work correctly
  </success_criteria>

<must_haves>

- config.IsPlain() returns bool based on KAMAJI_PLAIN or NO_COLOR env vars
- output.Style() applies lipgloss styling or plain ASCII based on IsPlain()
- output.Writer implements io.Writer with styled line prefixes
- Plain mode uses exact ASCII indicators from DESIGN.md: [ok], Error:, ->, Warning:, [DEBUG]
  </must_haves>
