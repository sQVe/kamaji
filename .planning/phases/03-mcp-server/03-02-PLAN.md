---
phase: 03-mcp-server
plan: 02
type: tdd
depends_on: ["03-01"]
files_modified:
    [
        internal/mcp/server.go,
        internal/mcp/server_test.go,
        internal/mcp/tools.go,
        internal/mcp/tools_test.go,
    ]
---

<objective>
Implement task_complete and note_insight tool handlers.

Purpose: Allow Claude Code to signal task completion and record insights via MCP.
Output: Two registered tools that parse inputs and return structured results.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@DESIGN.md
@internal/mcp/server.go
@.planning/phases/03-mcp-server/03-01-SUMMARY.md

**From DESIGN.md - MCP tools:**

```
task_complete(status, summary)
- status: "pass" | "fail"
- summary: what was done or why it failed
- Stored in ticket log, injected into future tasks

note_insight(text)
- Record discoveries useful for future tasks
- Stored in ticket log, injected into future tasks
```

**From mcp-go research:**

- Use `mcp.NewTool()` with `mcp.WithString()` for arguments
- Use `mcp.NewTypedToolHandler()` for type-safe handling
- Return `mcp.NewToolResultText()` or `mcp.NewToolResultError()`

**Orchestration note:**
The handlers return results; the orchestrator (Phase 10) handles:

- Persisting to ticket logs
- Calling RecordPass/RecordFail on state machine
- Git operations (commit on pass, reset on fail)

These handlers are pure: input → output, no side effects.
</context>

<feature>
  <name>task_complete tool</name>
  <files>internal/mcp/tools.go, internal/mcp/tools_test.go</files>
  <behavior>
    TaskCompleteArgs struct:
    - Status: string (required, must be "pass" or "fail")
    - Summary: string (required, non-empty)

    TaskCompleteResult struct:
    - Status: string
    - Summary: string
    - Acknowledged: bool (always true)

    HandleTaskComplete(ctx, req, args TaskCompleteArgs) (*mcp.CallToolResult, error):
    - Validates status is "pass" or "fail"
    - Validates summary is non-empty
    - Returns error result for invalid inputs
    - Returns structured result with acknowledgment

    Cases:
    - status="pass", summary="Done" → result with Acknowledged=true
    - status="fail", summary="Error" → result with Acknowledged=true
    - status="invalid", summary="X" → error "status must be pass or fail"
    - status="pass", summary="" → error "summary is required"

  </behavior>
  <implementation>
    Create typed handler using mcp.NewTypedToolHandler.
    Validate inputs before returning result.
    Use mcp.NewToolResultText with JSON-encoded result.
  </implementation>
</feature>

<feature>
  <name>note_insight tool</name>
  <files>internal/mcp/tools.go, internal/mcp/tools_test.go</files>
  <behavior>
    NoteInsightArgs struct:
    - Text: string (required, non-empty)

    NoteInsightResult struct:
    - Text: string
    - Recorded: bool (always true)

    HandleNoteInsight(ctx, req, args NoteInsightArgs) (*mcp.CallToolResult, error):
    - Validates text is non-empty
    - Returns error result for empty text
    - Returns structured result with recorded flag

    Cases:
    - text="Found pattern X" → result with Recorded=true
    - text="" → error "text is required"

  </behavior>
  <implementation>
    Same pattern as task_complete.
    Simple validation and structured result.
  </implementation>
</feature>

<feature>
  <name>Tool registration on Server</name>
  <files>internal/mcp/server.go, internal/mcp/server_test.go</files>
  <behavior>
    Server.RegisterTools():
    - Registers task_complete tool with schema and handler
    - Registers note_insight tool with schema and handler
    - Called automatically by NewServer or explicitly

    Integration test:
    - Start server, call tools via HTTP, verify responses

  </behavior>
  <implementation>
    Use s.mcpServer.AddTool() with mcp.NewTool() and handlers.
    Register in NewServer to ensure tools are always available.
  </implementation>
</feature>

<verification>
- `go test ./internal/mcp/...` passes
- `make test` passes (all unit tests)
- `make lint` passes
- Tools are registered and respond to valid/invalid inputs
</verification>

<success_criteria>

- RED: Failing tests for task_complete handler
- GREEN: task_complete implementation passes
- RED: Failing tests for note_insight handler
- GREEN: note_insight implementation passes
- Tools registered on Server
- All commits follow TDD pattern
- Phase 3 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server/03-02-SUMMARY.md`:

# Plan 03-02 Summary: Tool handlers

**[One-liner about what shipped]**

## Performance

- **Duration:** X min
- **Started:** YYYY-MM-DD
- **Completed:** YYYY-MM-DD

## TDD Cycles

### task_complete

- RED: [test description, why it failed]
- GREEN: [implementation approach]
- REFACTOR: [cleanup if any]

### note_insight

- RED: [test description, why it failed]
- GREEN: [implementation approach]
- REFACTOR: [cleanup if any]

## Files Created/Modified

- `internal/mcp/tools.go` - Tool handlers
- `internal/mcp/tools_test.go` - Handler unit tests
- `internal/mcp/server.go` - Tool registration

## Commits

| Commit | Description                                      |
| ------ | ------------------------------------------------ |
| ...    | test(03-02): add failing tests for task_complete |
| ...    | feat(03-02): implement task_complete handler     |
| ...    | test(03-02): add failing tests for note_insight  |
| ...    | feat(03-02): implement note_insight handler      |

## Phase 3 Status

Phase 3 (MCP Server) complete with all 2 plans finished:

- 03-01: MCP server infrastructure
- 03-02: Tool handlers

## Next Step

Phase complete, ready for Phase 4 (Context Injection)
</output>
