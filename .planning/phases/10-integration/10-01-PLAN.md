---
phase: 10-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
    - internal/orchestrator/run.go
autonomous: true

must_haves:
    truths:
        - "Run function executes tasks sequentially until sprint complete"
        - "Task completion signals are received and processed"
        - "Process exit without signal is treated as failure"
        - "Stuck state halts execution and returns"
        - "Context cancellation terminates cleanly"
        - "Insights are recorded during task execution"
    artifacts:
        - path: "internal/orchestrator/run.go"
          provides: "Run function and RunConfig/RunResult types"
          exports: ["Run", "RunConfig", "RunResult"]
    key_links:
        - from: "internal/orchestrator/run.go"
          to: "internal/mcp/server.go"
          via: "server.Signals() channel"
          pattern: "server\\.Signals\\(\\)"
        - from: "internal/orchestrator/run.go"
          to: "internal/process/spawn.go"
          via: "process.SpawnClaude call"
          pattern: "process\\.SpawnClaude"
        - from: "internal/orchestrator/run.go"
          to: "internal/orchestrator/handler.go"
          via: "handler.OnPass/OnFail calls"
          pattern: "handler\\.On(Pass|Fail)"
---

<objective>
Create the main sprint execution loop that orchestrates all components into a working end-to-end flow.

Purpose: This is the core integration that connects MCP server, process spawning, signal handling, and outcome processing into a single Run function that executes a sprint.

Output: `internal/orchestrator/run.go` with Run function, RunConfig, and RunResult types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-integration/10-RESEARCH.md

@internal/orchestrator/handler.go
@internal/orchestrator/result.go
@internal/mcp/server.go
@internal/mcp/tools.go
@internal/process/spawn.go
@internal/prompt/context.go
@internal/config/sprint.go
@internal/config/state.go
@internal/config/history.go
@internal/git/git.go
@internal/output/progress.go
@internal/statemachine/statemachine.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Run function with main loop</name>
  <files>internal/orchestrator/run.go</files>
  <action>
Create `internal/orchestrator/run.go` with:

1. **RunConfig struct:**
    - WorkDir string (required: project directory)
    - SprintPath string (required: path to kamaji.yaml)

2. **RunResult struct:**
    - Success bool (true if sprint completed)
    - TasksRun int (count of tasks executed)
    - Stuck bool (true if stuck threshold hit)
    - StuckReason string (last failure summary if stuck)

3. **Run function signature:**

    ```go
    func Run(ctx context.Context, cfg RunConfig) (*RunResult, error)
    ```

4. **Config validation at start:**

    ```go
    if cfg.WorkDir == "" {
        return nil, errors.New("WorkDir is required")
    }
    if cfg.SprintPath == "" {
        return nil, errors.New("SprintPath is required")
    }
    ```

5. **Main loop logic:**
    - Load sprint from cfg.SprintPath using config.LoadSprint
    - Load state from cfg.WorkDir using config.LoadState
    - Handle empty sprint (no tickets): output.PrintInfo("Sprint has no tasks"), return success immediately
    - Start MCP server with port 0 (dynamic), defer Shutdown
    - Create Handler with NewHandler(cfg.WorkDir, state, sprint)
    - Loop:
      a. Check ctx.Done() for cancellation
      b. Get next task via statemachine.NextTask
      c. If nil, sprint complete: output.PrintSprintComplete, return success
      d. If state.CurrentTask == 0 && state.FailureCount == 0, create branch for new ticket:
        - git.CreateBranch(cfg.WorkDir, sprint.BaseBranch, taskInfo.Ticket.Branch)
        - Handle "already exists" error gracefully: output.PrintInfo about using existing branch
        - output.PrintTicketStart(taskInfo.Ticket)
        - output.PrintBranchCreated(taskInfo.Ticket.Branch) (only if created)
          e. output.PrintTaskStart(taskInfo, sprint)
          f. Call runTask helper (Task 2)
          g. Increment tasksRun
          h. output.PrintSignal with result
          i. If result.Passed(): handler.OnPass
          j. Else: handler.OnFail, then check handler.IsStuck()
        - If stuck: handler.OnStuck(), return with Stuck=true, StuckReason=result.Summary

6. **Error handling:**
    - Return errors from config loading, server start, git operations, handler methods
    - On context cancellation, return nil error with ctx.Err() message logged

Do NOT create runTask yet - that's Task 2.
</action>
<verify>
File exists: `ls internal/orchestrator/run.go`
Compiles: `go build ./internal/orchestrator/...`
</verify>
<done>
Run function compiles with RunConfig and RunResult types exported. Main loop structure handles sprint completion, stuck detection, and context cancellation.
</done>
</task>

<task type="auto">
  <name>Task 2: Create runTask helper with signal handling</name>
  <files>internal/orchestrator/run.go</files>
  <action>
Add runTask helper function to `internal/orchestrator/run.go`:

1. **Function signature:**

    ```go
    func runTask(ctx context.Context, cfg RunConfig, sprint *domain.Sprint, state *domain.State, port int, taskInfo *statemachine.TaskInfo, server *mcp.Server) (TaskResult, error)
    ```

2. **Logic:**
   a. Assemble prompt: prompt.AssembleContext(sprint, state, cfg.WorkDir)
   b. Spawn Claude:

    ```go
    spawnResult, err := process.SpawnClaude(process.SpawnConfig{
        Prompt:  promptText,
        MCPPort: port,
        WorkDir: cfg.WorkDir,
        Stdout:  output.NewInfoWriter(os.Stdout),
        Stderr:  output.NewErrorWriter(os.Stderr),
    })
    ```

    c. Defer os.Remove(spawnResult.ConfigPath) for cleanup
    d. Create done channel and goroutine to wait for process:

    ```go
    done := make(chan struct{})
    go func() {
        _ = spawnResult.Process.Wait()
        close(done)
    }()
    ```

    e. Signal handling loop:

    ```go
    ticketName := taskInfo.Ticket.Name
    for {
        select {
        case <-ctx.Done():
            _ = spawnResult.Process.Kill()
            return TaskResult{}, ctx.Err()
        case sig, ok := <-server.Signals():
            if !ok {
                // Channel closed (server shutdown)
                return NoSignalResult(), nil
            }
            if sig.Tool == mcp.SignalToolNoteInsight {
                _ = config.RecordInsight(cfg.WorkDir, ticketName, sig.Summary)
                output.PrintSignal(sig)
                continue
            }
            // task_complete signal
            <-done // Wait for process to fully exit
            return ResultFromSignal(sig), nil
        case <-done:
            // Process exited without signal
            return NoSignalResult(), nil
        }
    }
    ```

3. **Imports needed:**
    - "context"
    - "errors"
    - "os"
    - "strings"
    - "github.com/sqve/kamaji/internal/config"
    - "github.com/sqve/kamaji/internal/domain"
    - "github.com/sqve/kamaji/internal/git"
    - "github.com/sqve/kamaji/internal/mcp"
    - "github.com/sqve/kamaji/internal/output"
    - "github.com/sqve/kamaji/internal/process"
    - "github.com/sqve/kamaji/internal/prompt"
    - "github.com/sqve/kamaji/internal/statemachine"
      </action>
      <verify>
      Compiles: `go build ./internal/orchestrator/...`
      Lints: `make lint`
      </verify>
      <done>
      runTask helper compiles and handles signal/exit race, insight recording, and context cancellation. Full orchestrator package builds without errors.
      </done>
      </task>

</tasks>

<verification>
```bash
# Build orchestrator package
go build ./internal/orchestrator/...

# Run linter

make lint

# Run existing orchestrator tests (should still pass)

go test ./internal/orchestrator/...

# Verify exports

go doc github.com/sqve/kamaji/internal/orchestrator | grep -E "^(func|type) (Run|RunConfig|RunResult)"

```
</verification>

<success_criteria>
- `internal/orchestrator/run.go` exists and compiles
- Run, RunConfig, RunResult are exported
- Main loop handles: sprint completion, stuck detection, context cancellation
- runTask handles: signal/exit race, insight recording, MCP config cleanup
- All existing orchestrator tests pass
- Linter passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-integration/10-01-SUMMARY.md`
</output>
```
