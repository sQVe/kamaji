---
phase: 10-integration
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
    - cmd/kamaji/start.go
    - cmd/kamaji/main.go
    - cmd/kamaji/testdata/script/start.txt
autonomous: true

must_haves:
    truths:
        - "User can run 'kamaji start' from terminal"
        - "Command uses current working directory as WorkDir"
        - "Command uses kamaji.yaml in current directory as SprintPath"
        - "Exit code 1 on failure or stuck, 0 on success"
        - "CLI has testscript coverage"
    artifacts:
        - path: "cmd/kamaji/start.go"
          provides: "Cobra start command"
          exports: ["startCmd"]
        - path: "cmd/kamaji/main.go"
          provides: "Root command with start subcommand"
          contains: "AddCommand"
        - path: "cmd/kamaji/testdata/script/start.txt"
          provides: "Testscript for start command"
    key_links:
        - from: "cmd/kamaji/start.go"
          to: "internal/orchestrator/run.go"
          via: "orchestrator.Run call"
          pattern: "orchestrator\\.Run"
        - from: "cmd/kamaji/main.go"
          to: "cmd/kamaji/start.go"
          via: "cmd.AddCommand"
          pattern: "AddCommand\\(startCmd"
---

<objective>
Wire the orchestrator.Run function to a CLI `start` command and add testscript coverage.

Purpose: Provides the user-facing entry point to run sprints via `kamaji start`, with testscript tests to verify CLI behavior.

Output: `cmd/kamaji/start.go` with Cobra command, `cmd/kamaji/main.go` updated to register it, testscript for basic verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-integration/10-01-SUMMARY.md

@cmd/kamaji/main.go
@cmd/kamaji/script_test.go
@cmd/kamaji/testdata/script/version.txt
@cmd/kamaji/testdata/script/help.txt
@internal/orchestrator/run.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create start command and wire to root</name>
  <files>cmd/kamaji/start.go, cmd/kamaji/main.go</files>
  <action>
Create `cmd/kamaji/start.go`:

```go
package main

import (
    "os"
    "path/filepath"

    "github.com/spf13/cobra"
    "github.com/sqve/kamaji/internal/orchestrator"
)

func startCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "start",
        Short: "Run sprint until complete or stuck",
        Long:  "Execute tasks sequentially from kamaji.yaml until the sprint completes or a task fails 3 consecutive times.",
        RunE: func(cmd *cobra.Command, args []string) error {
            workDir, err := os.Getwd()
            if err != nil {
                return err
            }

            result, err := orchestrator.Run(cmd.Context(), orchestrator.RunConfig{
                WorkDir:    workDir,
                SprintPath: filepath.Join(workDir, "kamaji.yaml"),
            })
            if err != nil {
                return err
            }

            if !result.Success {
                os.Exit(1)
            }
            return nil
        },
    }

    return cmd
}
```

Update `cmd/kamaji/main.go` to register the start command:

1. Read existing main.go
2. Add `cmd.AddCommand(startCmd())` to rootCmd()
3. Keep existing structure intact
   </action>
   <verify>
   Compiles: `go build ./cmd/kamaji/...`
   Start command help: `go run ./cmd/kamaji start --help` shows start command help
   </verify>
   <done>
   `kamaji start` command is available and shows proper help text. Binary compiles successfully.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Create testscript for start command</name>
  <files>cmd/kamaji/testdata/script/start.txt</files>
  <action>
Create `cmd/kamaji/testdata/script/start.txt` with testscript tests:

```
# Test: kamaji start --help works
exec kamaji start --help
stdout 'Run sprint until complete or stuck'
stdout 'Execute tasks sequentially'

# Test: kamaji start fails with missing kamaji.yaml
! exec kamaji start
stderr -count=1 '.'
```

Note: Full integration with actual sprint execution would require a mock Claude, which is tested in the Go integration tests. The testscript focuses on CLI argument handling and basic error cases.

The testscript uses the `kamaji` binary built by TestMain in script_test.go.
</action>
<verify>
Testscript passes: `go test ./cmd/kamaji/... -tags=integration -v`
</verify>
<done>
Testscript verifies start command help and error handling. CLI integration confirmed working.
</done>
</task>

</tasks>

<verification>
```bash
# Build binary
go build -o kamaji ./cmd/kamaji/...

# Verify start command exists

./kamaji --help | grep start

# Verify start command help

./kamaji start --help

# Clean up

rm kamaji

# Run testscripts (requires integration tag)

go test ./cmd/kamaji/... -tags=integration -v

# Run linter

make lint

# Run full CI

make ci

```
</verification>

<success_criteria>
- `cmd/kamaji/start.go` exists with startCmd function
- `cmd/kamaji/main.go` registers start as subcommand
- `cmd/kamaji/testdata/script/start.txt` exists with testscript tests
- `kamaji start --help` shows command help
- Binary compiles successfully
- Testscript tests pass
- Linter passes
</success_criteria>

<output>
After completion, create `.planning/phases/10-integration/10-03-SUMMARY.md`
</output>
```
