---
phase: 09-stuck-detection
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
    - internal/orchestrator/handler.go
    - internal/orchestrator/handler_test.go
autonomous: true

must_haves:
    truths:
        - "Pass handler commits changes and records completion"
        - "Fail handler resets to HEAD and records failure"
        - "Stuck handler outputs message and returns exit signal"
        - "State is persisted after each handler call"
    artifacts:
        - path: "internal/orchestrator/handler.go"
          provides: "Handler struct with OnPass, OnFail, OnStuck methods"
          exports: ["Handler", "NewHandler", "OnPass", "OnFail", "OnStuck"]
        - path: "internal/orchestrator/handler_test.go"
          provides: "Unit tests for handler"
    key_links:
        - from: "internal/orchestrator/handler.go"
          to: "statemachine.RecordPass"
          via: "OnPass calls RecordPass"
          pattern: "statemachine\\.RecordPass"
        - from: "internal/orchestrator/handler.go"
          to: "statemachine.RecordFail"
          via: "OnFail calls RecordFail"
          pattern: "statemachine\\.RecordFail"
        - from: "internal/orchestrator/handler.go"
          to: "git.ResetToHead"
          via: "OnFail calls ResetToHead"
          pattern: "git\\.ResetToHead"
        - from: "internal/orchestrator/handler.go"
          to: "config.SaveState"
          via: "State persisted after mutations"
          pattern: "config\\.SaveState"
---

<objective>
Create Handler that orchestrates pass/fail/stuck workflows.

Purpose: Phase 10 needs clean entry points for handling task outcomes. Instead of Phase 10 calling RecordPass + CommitChanges + RecordCompleted + SaveState individually, it calls `handler.OnPass(result)`. This encapsulates the orchestration logic.

Output: `internal/orchestrator/handler.go` with Handler struct and methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-stuck-detection/09-01-SUMMARY.md
@internal/statemachine/statemachine.go
@internal/git/git.go
@internal/config/state.go
@internal/config/history.go
@internal/output/progress.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Handler struct with dependencies</name>
  <files>internal/orchestrator/handler.go</files>
  <action>
Add `handler.go` to `internal/orchestrator` package:

1. Define Handler struct with injected dependencies:

    ```go
    type Handler struct {
        workDir string
        state   *domain.State
        sprint  *domain.Sprint
    }
    ```

2. Add constructor:

    ```go
    func NewHandler(workDir string, state *domain.State, sprint *domain.Sprint) *Handler
    ```

3. Add OnPass method:

    ```go
    func (h *Handler) OnPass(ticketName, taskDesc, summary string) error
    ```

    Workflow:
    - Call git.CommitChanges(workDir, summary)
    - Call config.RecordCompleted(workDir, ticketName, taskDesc, summary)
    - Call statemachine.RecordPass(state, sprint)
    - Call config.SaveState(workDir, state)
    - Call output.PrintCommitCreated(summary)
    - Return nil on success, error if any step fails

4. Add OnFail method:

    ```go
    func (h *Handler) OnFail(ticketName, taskDesc, summary string) error
    ```

    Workflow:
    - Call git.ResetToHead(workDir)
    - Call config.RecordFailed(workDir, ticketName, taskDesc, summary)
    - Call statemachine.RecordFail(state)
    - Call config.SaveState(workDir, state)
    - Call output.PrintResetPerformed()
    - Return nil on success, error if any step fails

5. Add OnStuck method:

    ```go
    func (h *Handler) OnStuck() error
    ```

    Workflow:
    - Call output.PrintSprintStuck(sprint, state)
    - Call config.SaveState(workDir, state) (preserve state for manual intervention)
    - Return nil (caller decides exit code)

6. Add IsStuck helper:

    ```go
    func (h *Handler) IsStuck() bool
    ```

    - Return statemachine.IsStuck(state)

Handle errors gracefully - if git commit fails but we already updated state, log the error but continue. Persist state before returning errors when possible.
</action>
<verify>go build ./internal/orchestrator/...</verify>
<done>Handler struct exists with OnPass, OnFail, OnStuck methods that compile</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for Handler</name>
  <files>internal/orchestrator/handler_test.go</files>
  <action>
Create `handler_test.go` with tests. Use temporary directories for isolation.

1. TestOnPass_CommitsAndAdvances:
    - Set up temp git repo with a file change
    - Call OnPass
    - Verify: commit exists, state advanced, history recorded, state persisted

2. TestOnFail_ResetsAndRecords:
    - Set up temp git repo with uncommitted changes
    - Call OnFail
    - Verify: changes reset, failure count incremented, history recorded, state persisted

3. TestOnFail_IncrementsToStuck:
    - Start with FailureCount=2
    - Call OnFail
    - Verify: IsStuck() returns true after

4. TestOnStuck_OutputsAndPreservesState:
    - Set up handler with stuck state (FailureCount=3)
    - Call OnStuck
    - Verify: state file still exists with preserved position

5. TestIsStuck_DelegatesToStateMachine:
    - Test with FailureCount < 3 returns false
    - Test with FailureCount >= 3 returns true

Use testutil package if available for git repo setup, otherwise create simple helpers.
</action>
<verify>go test ./internal/orchestrator/... -v</verify>
<done>All handler tests pass, covering pass/fail/stuck workflows</done>
</task>

</tasks>

<verification>
```bash
go build ./internal/orchestrator/...
go test ./internal/orchestrator/... -v
go vet ./internal/orchestrator/...
make lint
```
</verification>

<success_criteria>

- Handler struct with workDir, state, sprint dependencies
- OnPass commits, records completion, advances state, persists
- OnFail resets, records failure, increments failure count, persists
- OnStuck outputs message and preserves state
- IsStuck delegates to statemachine
- All tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/09-stuck-detection/09-02-SUMMARY.md`
</output>
