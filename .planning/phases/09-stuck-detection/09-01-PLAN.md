---
phase: 09-stuck-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
    - internal/orchestrator/result.go
    - internal/orchestrator/result_test.go
autonomous: true

must_haves:
    truths:
        - "Task result can represent pass, fail, or no-signal cases"
        - "No-signal case is treated as failure per DESIGN.md"
        - "Result includes summary for history recording"
    artifacts:
        - path: "internal/orchestrator/result.go"
          provides: "TaskResult type and constructors"
          exports: ["TaskResult", "PassResult", "FailResult", "NoSignalResult"]
        - path: "internal/orchestrator/result_test.go"
          provides: "Unit tests for result types"
    key_links:
        - from: "internal/orchestrator/result.go"
          to: "mcp.Signal"
          via: "ResultFromSignal constructor"
          pattern: "mcp\\.Signal"
---

<objective>
Create TaskResult type that normalizes pass/fail/no-signal outcomes.

Purpose: Phase 10 needs a unified way to handle task outcomes. The MCP server emits signals, but processes can also exit without signaling (crash, timeout, forgot to call task_complete). This plan creates the abstraction that treats no-signal as failure.

Output: `internal/orchestrator/result.go` with TaskResult type and constructors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/mcp/tools.go
@internal/statemachine/statemachine.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskResult type</name>
  <files>internal/orchestrator/result.go</files>
  <action>
Create new package `internal/orchestrator` with `result.go`:

1. Define TaskResult struct:
    - Status: "pass" | "fail" (no-signal normalized to "fail")
    - Summary: string (from signal or default "process exited without signal")
    - NoSignal: bool (true when process exited without task_complete)

2. Add constructors:
    - `PassResult(summary string) TaskResult` - creates pass result
    - `FailResult(summary string) TaskResult` - creates fail result
    - `NoSignalResult() TaskResult` - creates fail result with NoSignal=true, default summary
    - `ResultFromSignal(sig mcp.Signal) TaskResult` - converts MCP signal to result

3. Add methods:
    - `(r TaskResult) Passed() bool` - returns true if Status == "pass"
    - `(r TaskResult) Failed() bool` - returns true if Status == "fail"

Import mcp package for Signal type. Keep it simple - this is a data type with constructors.
</action>
<verify>go build ./internal/orchestrator/...</verify>
<done>TaskResult type exists with all constructors and methods, compiles without error</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for TaskResult</name>
  <files>internal/orchestrator/result_test.go</files>
  <action>
Create `result_test.go` with tests covering:

1. PassResult:
    - Status is "pass", summary preserved, NoSignal is false
    - Passed() returns true, Failed() returns false

2. FailResult:
    - Status is "fail", summary preserved, NoSignal is false
    - Passed() returns false, Failed() returns true

3. NoSignalResult:
    - Status is "fail", NoSignal is true
    - Summary contains meaningful default ("process exited without signal")
    - Failed() returns true

4. ResultFromSignal:
    - Signal with "pass" status creates pass result
    - Signal with "fail" status creates fail result
    - Summary is preserved from signal

Follow existing test patterns (see statemachine_test.go).
</action>
<verify>go test ./internal/orchestrator/... -v</verify>
<done>All tests pass, coverage includes all constructors and methods</done>
</task>

</tasks>

<verification>
```bash
go build ./internal/orchestrator/...
go test ./internal/orchestrator/... -v
go vet ./internal/orchestrator/...
```
</verification>

<success_criteria>

- TaskResult type defined with Status, Summary, NoSignal fields
- All four constructors work correctly
- Passed() and Failed() methods work
- NoSignalResult creates a failure with meaningful default summary
- All tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/09-stuck-detection/09-01-SUMMARY.md`
</output>
