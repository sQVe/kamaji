---
phase: 04-context-injection
plan: 02
type: execute
depends_on: ["04-01"]
files_modified: [internal/prompt/context.go, internal/prompt/context_test.go]
---

<objective>
Create AssembleContext function that orchestrates context assembly.

Purpose: Integrate BuildPrompt with existing config and state machine for complete context generation.
Output: AssembleContext function ready for Phase 5 process spawning.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-context-injection/04-01-SUMMARY.md
@internal/prompt/prompt.go
@internal/statemachine/statemachine.go
@internal/config/history.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: AssembleContext function</name>
  <files>internal/prompt/context.go</files>
  <action>
    Create AssembleContext that orchestrates context generation:

    Signature:
    ```go
    func AssembleContext(sprint *domain.Sprint, state *domain.State, kamajiDir string) (string, error)
    ```

    Implementation:
    1. Call statemachine.NextTask(state, sprint) to get current TaskInfo
    2. If nil (sprint complete), return empty string with no error
    3. Load TicketHistory via config.LoadTicketHistory(kamajiDir, ticket.Name)
    4. Call BuildPrompt(taskInfo, sprint.Rules, &history)
    5. Return the generated XML string

    Error handling:
    - history loading errors: log warning, continue with empty history (graceful degradation)
    - nil sprint or state: return error

  </action>
  <verify>go build ./internal/prompt/... compiles without errors</verify>
  <done>AssembleContext function exists and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests</name>
  <files>internal/prompt/context_test.go</files>
  <action>
    Add tests for AssembleContext:

    Test cases:
    1. Full sprint with history → complete XML output
    2. Sprint without history file → XML with empty history sections
    3. Sprint at completion (NextTask returns nil) → empty string, no error
    4. Nil sprint → error returned
    5. Nil state → error returned

    Use t.TempDir() for test fixture directories.
    Create minimal kamaji.yaml and history files for realistic testing.

  </action>
  <verify>go test ./internal/prompt/... -v passes all tests</verify>
  <done>All 5 test cases pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./internal/prompt/...` passes
- [ ] `make test` passes all tests
- [ ] `make lint` passes with 0 issues
- [ ] AssembleContext integrates correctly with existing packages
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Phase 4 complete - context injection ready for Phase 5
  </success_criteria>

<output>
After completion, create `.planning/phases/04-context-injection/04-02-SUMMARY.md`:

# Phase 04 Plan 02: Context Assembly Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `internal/prompt/context.go` - AssembleContext function
- `internal/prompt/context_test.go` - Integration tests

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 4 complete, ready for Phase 5 (Process Spawning)
</output>
