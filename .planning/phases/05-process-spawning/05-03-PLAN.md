---
phase: 05-process-spawning
plan: 03
type: execute
depends_on: ["05-01", "05-02"]
files_modified:
    [
        internal/process/config.go,
        internal/process/config_test.go,
        internal/process/spawn.go,
        internal/process/spawn_test.go,
    ]
---

<objective>
Integrate MCP config generation, context injection, and process spawning.

Purpose: Provide high-level function that orchestrator calls to launch Claude Code with full context and MCP server connection.
Output: SpawnClaude function that sets up MCP config and launches process with injected context.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-process-spawning/05-01-SUMMARY.md
@.planning/phases/05-process-spawning/05-02-SUMMARY.md
@internal/process/process.go
@internal/mcp/server.go
@internal/prompt/context.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP config file generation</name>
  <files>internal/process/config.go, internal/process/config_test.go</files>
  <action>
    Create WriteMCPConfig function that generates .mcp.json file for Claude Code.

    func WriteMCPConfig(dir string, port int) (string, error)
    - Creates .mcp.json in specified directory
    - Content: {"mcpServers":{"kamaji":{"type":"http","url":"http://localhost:PORT/mcp"}}}
    - Returns path to created file
    - If dir is empty, use os.TempDir()

    JSON structure matches Claude Code's expected format for HTTP MCP servers.
    Use encoding/json for proper escaping.

    Tests:
    - WriteMCPConfig creates file with correct JSON
    - Port is correctly interpolated into URL
    - File is readable and parseable as JSON
    - Empty dir defaults to temp directory

  </action>
  <verify>go test -v ./internal/process/... -run MCP</verify>
  <done>WriteMCPConfig creates valid .mcp.json, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Spawn integration function</name>
  <files>internal/process/spawn.go, internal/process/spawn_test.go</files>
  <action>
    Create SpawnClaude function that ties everything together.

    type SpawnConfig struct {
      Prompt     string    // Required: context from AssembleContext
      MCPPort    int       // Required: port from MCP server
      WorkDir    string    // Required: project directory to run in
      Stdout     io.Writer // Optional: defaults to os.Stdout
      Stderr     io.Writer // Optional: defaults to os.Stderr
    }

    func SpawnClaude(cfg SpawnConfig) (*Process, error)
    1. Validate required fields (Prompt, MCPPort > 0, WorkDir non-empty)
    2. Write MCP config to WorkDir/.mcp.json
    3. Create Process with:
       - prompt from cfg.Prompt
       - WithDir(cfg.WorkDir)
       - WithStdout/WithStderr if provided
    4. Call process.Start()
    5. Return process (caller owns Wait/Kill)

    Note: Do NOT start MCP server here - that's orchestrator's job.
    This function assumes MCP server is already running.

    Tests:
    - SpawnClaude validates required fields
    - SpawnClaude creates .mcp.json in WorkDir
    - SpawnClaude returns started process
    - Error if Prompt empty
    - Error if MCPPort <= 0
    - Error if WorkDir empty

  </action>
  <verify>go test -v ./internal/process/... -run Spawn</verify>
  <done>SpawnClaude creates config, starts process, returns process handle</done>
</task>

<task type="auto">
  <name>Task 3: Integration test with mock process</name>
  <files>internal/process/spawn_test.go</files>
  <action>
    Add integration test that verifies full flow without spawning real Claude.

    TestSpawnClaude_Integration:
    1. Create temp directory
    2. Call SpawnClaude with mock prompt and valid port
    3. Verify .mcp.json exists with correct content
    4. Verify process was started (process.cmd.Process != nil)
    5. Kill process and clean up

    Use build tag or skip if CI to avoid flaky tests.
    The test verifies wiring, not Claude behavior.

  </action>
  <verify>go test -v ./internal/process/... -run Integration</verify>
  <done>Integration test passes, full spawn flow verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./internal/process/...` passes
- [ ] `make test` passes (all unit tests)
- [ ] `make lint` passes
- [ ] .mcp.json file format is valid JSON
</verification>

<success_criteria>

- WriteMCPConfig creates valid .mcp.json
- SpawnClaude integrates config + process creation
- All validation errors handled
- Tests pass without spawning real Claude
- Phase 5 complete
  </success_criteria>

<output>
After completion, create `.planning/phases/05-process-spawning/05-03-SUMMARY.md`:

# Phase 05 Plan 03: Context Injection & Launch Summary

**[One-liner describing what shipped]**

## Performance

- **Duration:** X min
- **Started:** YYYY-MM-DD
- **Completed:** YYYY-MM-DD

## Accomplishments

- WriteMCPConfig generates .mcp.json for Claude Code
- SpawnClaude integrates MCP config + process spawning
- Full spawn flow tested with mock process

## Task Commits

- `...` feat(05-03): add MCP config file generation
- `...` feat(05-03): add SpawnClaude integration function
- `...` test(05-03): add integration test for spawn flow

## Files Created/Modified

- `internal/process/config.go` - WriteMCPConfig function
- `internal/process/config_test.go` - Config tests
- `internal/process/spawn.go` - SpawnClaude function
- `internal/process/spawn_test.go` - Spawn and integration tests

## Decisions Made

- MCP config written to WorkDir/.mcp.json (project-local scope)
- SpawnClaude returns process handle, caller owns lifecycle
- MCP server must be started before SpawnClaude (orchestrator responsibility)

## Next Phase Readiness

Phase 5 complete. Ready for Phase 6: Git Operations

- Process spawning infrastructure ready
- MCP server can signal task completion
- Orchestrator can coordinate process + MCP + state machine
  </output>
