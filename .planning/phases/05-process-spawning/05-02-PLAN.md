---
phase: 05-process-spawning
plan: 02
type: tdd
depends_on: []
files_modified: [internal/process/process.go, internal/process/process_test.go]
---

<objective>
Create Claude Code process manager with lifecycle control.

Purpose: Wrap exec.Command with clean API for spawning Claude Code, capturing output, and managing process lifecycle.
Output: Process struct with Start, Wait, Kill methods and output streaming.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-process-spawning/05-01-SUMMARY.md
</context>

<feature>
  <name>Claude Process Manager</name>
  <files>internal/process/process.go, internal/process/process_test.go</files>
  <behavior>
    Process struct manages Claude Code subprocess:
    - cmd: *exec.Cmd (internal)
    - stdout, stderr: io.Writer (for output capture)

    NewProcess(prompt string, opts ...Option) *Process
    - Creates exec.Command for "claude" with args: -p, prompt, --dangerously-skip-permissions
    - Default: stdout/stderr go to os.Stdout/os.Stderr

    Options:
    - WithStdout(w io.Writer) - redirect stdout
    - WithStderr(w io.Writer) - redirect stderr
    - WithDir(dir string) - set working directory
    - WithEnv(env []string) - set environment variables

    Methods:
    - Start() error - start process (non-blocking)
    - Wait() error - wait for process to exit, return exit error if non-zero
    - Kill() error - send SIGKILL to process

    Test cases (use mock command like "echo" or "cat"):
    - NewProcess creates command with correct args
    - Start launches process
    - Wait returns nil on success (exit 0)
    - Wait returns error on failure (exit non-zero)
    - Kill terminates running process
    - WithStdout captures output
    - WithStderr captures errors
    - WithDir sets working directory
    - WithEnv passes environment

  </behavior>
  <implementation>
    1. Create internal/process package
    2. Define Process struct with cmd, stdout, stderr fields
    3. Implement NewProcess with default stdout/stderr to os.Stdout/os.Stderr
    4. Implement Option functions
    5. Implement Start() calling cmd.Start()
    6. Implement Wait() calling cmd.Wait()
    7. Implement Kill() calling cmd.Process.Kill()

    Testing strategy:
    - Use "echo" command for output capture tests
    - Use "false" command for exit error tests
    - Use "sleep" command for kill tests
    - Do NOT spawn actual Claude in tests

  </implementation>
</feature>

<verification>
go test -v ./internal/process/...
</verification>

<success_criteria>

- Process struct with Start, Wait, Kill methods
- Option pattern for stdout, stderr, dir, env configuration
- Tests pass using mock commands (echo, false, sleep)
- No actual Claude spawning in tests
- 2-3 commits: test(05-02), feat(05-02), optional refactor(05-02)
  </success_criteria>

<output>
After completion, create `.planning/phases/05-process-spawning/05-02-SUMMARY.md`:

# Phase 05 Plan 02: Claude Process Manager Summary

**[One-liner describing what shipped]**

## Performance

- **Duration:** X min
- **Started:** YYYY-MM-DD
- **Completed:** YYYY-MM-DD

## TDD Cycles

### Process lifecycle

- **RED:** [What test was written, why it failed]
- **GREEN:** [What implementation made it pass]
- **REFACTOR:** [What cleanup was done, if any]

## Files Created/Modified

- `internal/process/process.go` - Process struct with lifecycle methods
- `internal/process/process_test.go` - Unit tests using mock commands

## Commits

| Commit | Description                                        |
| ------ | -------------------------------------------------- |
| ...    | test(05-02): add failing tests for process manager |
| ...    | feat(05-02): implement process manager             |

## Next Step

Ready for 05-03-PLAN.md (context injection and launch)
</output>
